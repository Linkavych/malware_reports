# Data Encoding

## Lab 13-1

Analyze the malware found in the file Lab13-01.exe.

1. Compare the strings in the malware (from the output of the strings com-
mand) with the information available via dynamic analysis. Based on this
comparison, which elements might be encoded?

> The c2 server string is likely encoded using XOR.

2. Use IDA Pro to look for potential encoding by searching for the string
xor. What type of encoding do you find?

> The sample uses XOR encoding and Base64 encoding.

3. What is the key used for encoding and what content does it encode?

> There are actually two keys to decrypt the data stored in the .rsrc sectrion: 0x1b and 0x3b.
> The key used by the malware is `0x3b`, and this will decrypt the string to to 
> `www.practicalmalwareanalysis.com`. `0x1b` will do the same, but all uppercase.

4. Use the static tools FindCrypt2, Krypto ANALyzer (KANAL), and the
IDA Entropy Plugin to identify any other encoding mechanisms. What
do you find?

> Base64 encoding, standard alphabet

5. What type of encoding is used for a portion of the network traffic sent by
the malware?

> base64 encoding

6. Where is the Base64 function in the disassembly?

> 0x004018be

7. What is the maximum length of the Base64-encoded data that is sent?
What is encoded?

> The sample will take in 12 characters from the call to gethostname, and with encoding could be a max of 16 bytes.

8. In this malware, would you ever see the padding characters (= or ==) in
the Base64-encoded data?

> Yes, if the length is less than 12 bytes and cannot be divided by 3

9. What does this malware do?

> This sample will beacon to the URL with a GET request containing the encoded hostname of the system. If it receives a specific response, it quits.

## Lab 13-2

Analyze the malware found in the file Lab13-02.exe.

1. Using dynamic analysis, determine what this malware creates.

> The sample creates a screenshot of size 29861kb. The name format is `temp%08x`, and the file is XOR encrypted.

2. Use static techniques such as an xor search, FindCrypt2, KANAL, and the
IDA Entropy Plugin to look for potential encoding. What do you find?

> There are two XOR functions present in the sample: 0x00401739 and 0x00401570.

3. Based on your answer to question 1, which imported function would be a
good prospect for finding the encoding functions?

> `WriteFile`

4. Where is the encoding function in the disassembly?

> `0x00401739`

5. Trace from the encoding function to the source of the encoded content.
What is the content?

> An image file (screenshot).

6. Can you find the algorithm used for encoding? If not, how can you
decode the content?

> It is a custom implementation, and not easily determined. Emulation is the best way to decode the files.

7. Using instrumentation, can you recover the original source of one of the
encoded files?

> Using a debugger, st a break point on the call to the encryption subroutine. Follow EAX in memory, and dump this to a file. It may dump extra data, so in a hex edito ensure the magic bytes for a BITMAP
> are first, `42 4d`. Open in a standard image viewer.


## Lab 13-3

Analyze the malware found in the file Lab13-03.exe.

1. Compare the output of strings with the information available via
dynamic analysis. Based on this comparison, which elements might
be encoded?

2. Use static analysis to look for potential encoding by searching for the
string xor. What type of encoding do you find?

3. Use static tools like FindCrypt2, KANAL, and the IDA Entropy Plugin to
identify any other encoding mechanisms. How do these findings com-
pare with the XOR findings?

> AES encryption and a custom base64 imnplementation.

4. Which two encoding techniques are used in this malware?

> AES and custom base64

5. For each encoding technique, what is the key?

> AES - lkjiponmtsrqxwvu
> base64 - CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/

6. For the cryptographic encryption algorithm, is the key sufficient? What
else must be known?

> The type of AES that was used to encrypt the data. KGA, key size, mode of operation, and IV if used.

7. What does this malware do?

> This malware establishes a reverse shell connection. The commands are transmitted base64 encoded using the custom routine, and 
> the data returned by the reverse shell is AES encrypted before and decrypted on the receiving end.

8. Create code to decrypt some of the content produced during dynamic
analysis. What is this content?

```python
#!/usr/bin/env python3
# A custom base64 decoding program
# author: @linkavych
# date: 2022-08-27
import sys
import base64

new_b64 = "CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab0123456789+/"
std_b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

def b64_decode(data: str):
    '''
    Decode the base64 encoded string
    '''
    data = str(data).translate(str(data).maketrans(new_b64, std_b64))

    return base64.b64decode(data).decode()

if __name__ == '__main__':
    decoded = b64_decode(sys.argv[1])
    print(f"Decoded: {decoded}")
```

```python
#!/usr/bin/env python3
# Decrypt data from the sample
# Lab 13-3 - PMA
# author: @linkavych
# date: 2022-08-27
import sys
from Crypto.Cipher import AES

KEY = b'ijklmnopqrstuvwx'

with open(sys.argv[1], 'rb') as f:
    data = f.read()

aes_obj = AES.new(KEY, AES.MODE_CBC)

print(f"Plaintext: \n{aes_obj.decrypt(data)}")
```

